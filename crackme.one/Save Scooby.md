To solve this challenge I used GHIDRA, radare2, and a beautiful notepad to write the C keygenerator.

A first look at the main in GHIDRA showed the following code:

```c
undefined8 main(void)

{
  size_t sVar1;
  char local_1128 [256];
  char local_1028 [4108];
  int local_1c;
  int local_18;
  int local_14;
  int local_10;
  int local_c;
  
  getcwd(local_1028,0x1000);
  sVar1 = strlen(local_1028);                    
  local_18 = (int)sVar1; /* local_18 = Length of absolute pathname of the current working directory */
  local_c = 0;
  while (local_c < local_18) {
    if (local_1028[local_c] == '/') {
      local_1028[local_c] = '$';
    }
    else {
      if ((local_1028[local_c] < 'a') || ('z' < local_1028[local_c])) {
        if (('@' < local_1028[local_c]) && (local_1028[local_c] < '[')) {
          local_1028[local_c] = local_1028[local_c] + '\x1e';
        }
      }
      else {
        local_1028[local_c] = local_1028[local_c] + -0x1e;
      }
    }
    local_c = local_c + 1;
  }
  puts("Hi Scooby !!\nWhere are you??");
  __isoc99_scanf(&DAT_00100985,local_1128);
  sVar1 = strlen(local_1128);
                    /* locale_1128 = User input
                       locale_lc = Length of user input
                       locale_10 = counter */
  local_1c = (int)sVar1;
  local_10 = 0;
  local_14 = 0;
  while( true ) {
    if ((local_1c <= local_10) || (local_18 <= local_10)) goto LAB_001008b2;
    if (local_1028[local_10] != local_1128[local_10]) break;
    local_10 = local_10 + 1;
  }
  local_14 = -1;
LAB_001008b2:
  if (local_14 == 0) {
    puts("\nYou won a medal Scooby !!");
  }
  else {
    puts("\nScooby Doobie Doo!! Not too easy");
  }
  return 0;
}

```
We will look at the part where the user inputs the answer to the question "Hi Scooby !!\nWhere are you??"
```c
puts("Hi Scooby !!\nWhere are you??");
  __isoc99_scanf(&DAT_00100985,local_1128);
  sVar1 = strlen(local_1128);
  local_1c = (int)sVar1;
  local_10 = 0;
  local_14 = 0;
```
This yields to:  
* locale_1128 = User input
* locale_lc = Length of user input
* locale_10 = counter 
* local_1028 = Absolute path of current working directory   

Then there is a bunch of if statements. Important for us  is that if the first if statement ```if ((local_1c <= local_10) || (local_18 <= local_10)) goto LAB_001008b2;``` is satisfied we will get the jump to our success message.  
In our case either the length of the user input or the absolute path to the working directory needs to be less or equal to the counter variable local_10. If we would want to get this done with the first iteration we would need to input a zero length character which I do not know how to do (if its possible since scanf takes only strings). 
The second if-statement check if the character at the index[local10] of the path and input is not equal. If they are not eqal the program will set local_14 to -1 and exit unsuccessful.  
So the first guess is that the input and path needs to be equal.
```c  
  while( true ) {
    /*If the length of the user input is */
    if ((local_1c <= local_10) || (local_18 <= local_10)) goto LAB_001008b2;
    if (local_1028[local_10] != local_1128[local_10]) break;
    local_10 = local_10 + 1;
  }
  local_14 = -1;
LAB_001008b2:
  if (local_14 == 0) {
    puts("\nYou won a medal Scooby !!");
  }
  else {
    puts("\nScooby Doobie Doo!! Not too easy");
  }
  return 0;
```
This would not work since we have ignored the while loop before:  
Remember that 
local_c = 0
local_1028 = Absolute path of current working directory  
local_18 = length of local_1028
```c
while (local_c < local_18) {
    if (local_1028[local_c] == '/') {
      local_1028[local_c] = '$';
    }
    else {
      if ((local_1028[local_c] < 'a') || ('z' < local_1028[local_c])) {
        if (('@' < local_1028[local_c]) && (local_1028[local_c] < '[')) {
          local_1028[local_c] = local_1028[local_c] + '\x1e';
        }
      }
      else {
        local_1028[local_c] = local_1028[local_c] + -0x1e;
      }
    }
    local_c = local_c + 1;
  }
```
So I thougt I give it a shot implementing this into C. Important to mention is that it needs to be executed in the same folder as where the scooby file is at. Also the char array local_1028 needs to be filled with the working directory we are working in.
#include <stdio.h>

int main() {
	int local_c = 0;
	int local_18 = 32;
	char local_1028[] = {FILL WITH UR PATH AS CHAR ARRAY};

	while (local_c < local_18) {
    		if (local_1028[local_c] == '/') {
     		local_1028[local_c] = '$';
    	}
    		else {
      			if ((local_1028[local_c] < 'a') || ('z' < local_1028[local_c])) {
        			if (('@' < local_1028[local_c]) && (local_1028[local_c] < '[')) {
          				local_1028[local_c] = local_1028[local_c] + '\x1e';
        			}
      			}
      			else {
        			local_1028[local_c] = local_1028[local_c] + -0x1e;
      			}
    		}
    		local_c = local_c + 1;
	}
	printf("Value of local_1028\n");

	for(int i=0;i<sizeof(local_1028);i++){
		printf("%c",local_1028[i]);		
	}
printf("\n");
}
```
This will shift characters of the working directory which can be used as flag for this challenge.

Thanks for the nice challenge mrT4ntr4 !!
