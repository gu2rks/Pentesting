## Sh4ll10
A little crackme so you don't forget that the only thing you can trust is assembler. You don't need to open a debugger for this one. The goal is to fix the segfault by submitting the good string.  

Executing the application with an arbitrary password would result in a segmentation fault. So I fired up radare2 and looked into the main function. 

```assembly
/ (fcn) main 161
|   main (int argc, char **argv, char **envp);
|           ; var int local_23h @ rbp-0x23
|           ; var int local_22h @ rbp-0x22
|           ; var int local_21h @ rbp-0x21
|           ; var int local_20h @ rbp-0x20
|           ; var int local_18h @ rbp-0x18
|           ; var int local_9h @ rbp-0x9
|           ; var int local_8h @ rbp-0x8
|           ; DATA XREF from entry0 (0x40053d)
|           0x00400622      55             push rbp
|           0x00400623      4889e5         mov rbp, rsp
|           0x00400626      4883ec30       sub rsp, 0x30               ; '0'
|           0x0040062a      bf65074000     mov edi, str.Give_me_your_password: ; 0x400765 ; "Give me your password: "
|           0x0040062f      b800000000     mov eax, 0
|           0x00400634      e8a7feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x00400639      48c745f87d07.  mov qword [local_8h], str.er2rg2e1h94flagergjerj ; 0x40077d ; "er2rg2e1h94flagergjerj"
|           0x00400641      c645dd25       mov byte [local_23h], 0x25  ; '%' ; 37
|           0x00400645      c645f773       mov byte [local_9h], 0x73   ; 's' ; 115
|           0x00400649      0fb645f7       movzx eax, byte [local_9h]
|           0x0040064d      83f003         xor eax, 3
|           0x00400650      8845de         mov byte [local_22h], al
|           0x00400653      c645df00       mov byte [local_21h], 0
|           0x00400657      488d55e0       lea rdx, qword [local_20h]
|           0x0040065b      488d45dd       lea rax, qword [local_23h]
|           0x0040065f      4889d6         mov rsi, rdx
|           0x00400662      4889c7         mov rdi, rax
|           0x00400665      b800000000     mov eax, 0
|           0x0040066a      e891feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0040066f      488b45e0       mov rax, qword [local_20h]
|           0x00400673      480fbe55f7     movsx rdx, byte [local_9h]
|           0x00400678      48f7da         neg rdx
|           0x0040067b      4801d0         add rax, rdx                ; '('
|           0x0040067e      488945e0       mov qword [local_20h], rax
|           0x00400682      488b45e0       mov rax, qword [local_20h]
|           0x00400686      ffd0           call rax
|           0x00400688      48c745e00000.  mov qword [local_20h], 0
|           0x00400690      488b45e0       mov rax, qword [local_20h]
|           0x00400694      4885c0         test rax, rax
|       ,=< 0x00400697      741e           je 0x4006b7
|       |   0x00400699      488b55e8       mov rdx, qword [local_18h]
|       |   0x0040069d      488b45f8       mov rax, qword [local_8h]
|       |   0x004006a1      4889d6         mov rsi, rdx
|       |   0x004006a4      4889c7         mov rdi, rax
|       |   0x004006a7      e844feffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)
|       |   0x004006ac      85c0           test eax, eax
|      ,==< 0x004006ae      7507           jne 0x4006b7
|      ||   0x004006b0      e83dffffff     call sym.goodBoy
|     ,===< 0x004006b5      eb05           jmp 0x4006bc
|     |``-> 0x004006b7      e84effffff     call sym.badBoy
|     |     ; CODE XREF from main (0x4006b5)
|     `---> 0x004006bc      b800000000     mov eax, 0
|           0x004006c1      c9             leave
\           0x004006c2      c3             ret

```
### Pre-Scanf
We will look at the pre-scanf part first.
```assembly
|           0x0040062a      bf65074000     mov edi, str.Give_me_your_password: ; 0x400765 ; "Give me your password: "
|           0x0040062f      b800000000     mov eax, 0
|           0x00400634      e8a7feffff     call sym.imp.printf         ; int printf(const char *format)
|           0x00400639      48c745f87d07.  mov qword [local_8h], str.er2rg2e1h94flagergjerj ; 0x40077d ; "er2rg2e1h94flagergjerj"
|           0x00400641      c645dd25       mov byte [local_23h], 0x25  ; '%' ; 37
|           0x00400645      c645f773       mov byte [local_9h], 0x73   ; 's' ; 115
|           0x00400649      0fb645f7       movzx eax, byte [local_9h]
|           0x0040064d      83f003         xor eax, 3
|           0x00400650      8845de         mov byte [local_22h], al
|           0x00400653      c645df00       mov byte [local_21h], 0
|           0x00400657      488d55e0       lea rdx, qword [local_20h]
|           0x0040065b      488d45dd       lea rax, qword [local_23h]
|           0x0040065f      4889d6         mov rsi, rdx
|           0x00400662      4889c7         mov rdi, rax
|           0x00400665      b800000000     mov eax, 0
|           0x0040066a      e891feffff     call sym.imp.scanf          ; int scanf(const char *format)
```
Here we see that local_8h is assigned the constant **er2rg2e1h94flagergjerj** which if used as password will yield the answer "Bad Boy". Afterwards we see that "%s" is  stored in the stack. This could be an argument of the scanf function as stated in the c++ documentary.  

**s***, String of characters. Any number of non-whitespace characters, stopping at the first whitespace character found. A terminating null character is automatically added at the end of the stored sequence.  

But this is just to fool us since its being stored in eax and xored by 3 which results in a **p**. Checking the documentation for **p**.  
**p**	Pointer address	A sequence of characters representing a pointer. The particular format used depends on the system and library implementation, but it is the same as the one used to format %p in fprintf.  
So we know its a pointer. The address of **%p** is stored in rax and then moved to rdi before scanf is called.  

So we look at the code after scanf:  
### After-Scanf
 ```assembly
 0x0040066a      e891feffff     call sym.imp.scanf          ; int scanf(const char *format)
|           0x0040066f      488b45e0       mov rax, qword [local_20h]
|           0x00400673      480fbe55f7     movsx rdx, byte [local_9h]
|           0x00400678      48f7da         neg rdx
|           0x0040067b      4801d0         add rax, rdx                ; '('
|           0x0040067e      488945e0       mov qword [local_20h], rax
|           0x00400682      488b45e0       mov rax, qword [local_20h]
|           0x00400686      ffd0           call rax
```
The result of scanf is stored into rax and afterwards some hex arithmetric is performed. At this point we can see that we need to make the **call rax** jump to the **call sym.goodBoy**.  
RDX is the negated 73 so FFFFFF8D.  
The call to sym.goodBoy is at 004006b0  
So what does our input need to be ?  
```
 ????????
+FFFFFF8D
 004006b0
```
The answer is **00400723**!
