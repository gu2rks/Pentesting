Load binary in GHIDRA, GDB, or radare2  

## Way 1 / GHIDRA
1. Go into the main function in GHIDRA
1. In the decompile view there is this strange variable "local_14" assigned with "ksuiealohgy" in line 15
1. "local_14" is used further down in line 27 in a big if clause
1. It is easy to see that certain addresses of this char pointer are compared to other variables

```c
undefined4 main(undefined1 param_1)
{
  long lVar1;
  undefined4 uVar2;
  char local_1e;
  char local_1d;
  char local_1c;
  char local_1b;
  char *local_14;
  undefined1 *local_c;
  
  local_c = &param_1;
  local_14 = "ksuiealohgy";
  lVar1 = ptrace(PTRACE_TRACEME,0,1,0);
  if (lVar1 < 0) {
    puts("Debugger detecté ... Exit");
    uVar2 = 1;
  }
  else {
    puts("############################################################");
    puts("##        Bienvennue dans ce challenge de cracking        ##");
    puts("############################################################\n");
    printf("Password : ");
    fgets(&local_1e,9,(FILE *)stdin);
    if ((((local_1e == local_14[4]) && (local_1d == local_14[5])) && (local_1c == local_14[1])) &&
       (local_1b == local_14[10])) {
      puts("\nGood password !!!\n");
    }
    else {
      puts("\nWrong password.\n");
    }
    uVar2 = 0;
  }
  return uVar2;
}

```
Through mapping we can find out:  
local_14 = "ksuiealohgy"
local_14[0] = k  
local_14[1] = s  
local_14[2] = u  
...  

which yields to "easy" hooray!

## Way 2 / Patching the bin file using radare2 and gdb
1. If we want to run the bin file through a debugger we will get the error

```console
0x080482f0]> dc
Debugger detecté ... Exit
[0xf7f4b079]> 
```
Looking at the code in the main function using GHIDRA we see the following
```c
  lVar1 = ptrace(PTRACE_TRACEME,0,1,0);
  if (lVar1 < 0) {
    puts("Debugger detecté ... Exit");
    uVar2 = 1;
  }
```
So we need to jump over this check to be able to debug the application. Therefore we use radare2 in writing mode.  
radare2 -w ch3.bin

Commands in radare2:  
1. aaa
1. s sym.main
1. pdf
1. Identify the jump 
```console
x08048410      e85b060100     call sym.ptrace
|           0x08048415      83c410         add esp, 0x10
|           0x08048418      85c0           test eax, eax
|       ,=< 0x0804841a      791a           jns 0x8048436
|       |   0x0804841c      83ec0c         sub esp, 0xc
|       |   0x0804841f      6894280c08     push str.Debugger_detect___..._Exit ; 0x80c2894 ; "Debugger detect\u00e9 ... Exit" ; const char *s
|       |   0x08048424      e8a70e0000     call sym.puts               ; int puts(const char *s)
```
1. s 0x0804841a
1. Replace the conditional jump with our version
```console
[0x0804841a]> wa jmp 0x8048436
Written 2 bytes (jmp 0x8048436) = wx eb1a
```
1. q to close  

Since we have enabled debugging we can now start doing exactly that.  
```console
(gdb) break main
Breakpoint 1 at 0x80483fe
(gdb) run
Starting program: /root/rootMEzips/ch3_new.bin 
Breakpoint 1, 0x080483fe in main ()
disassemble main
Dump of assembler code for function main:
.....
   0x0804849d <+173>:	hlt    
   0x0804849e <+174>:	add    eax,0x4
   0x080484a1 <+177>:	mov    al,BYTE PTR [eax]
   0x080484a3 <+179>:	cmp    dl,al
   0x080484a5 <+181>:	jne    0x80484e4 <main+244>
   0x080484a7 <+183>:	mov    dl,BYTE PTR [ebp-0x15]
   0x080484aa <+186>:	mov    eax,DWORD PTR [ebp-0xc]
   0x080484ad <+189>:	add    eax,0x5
   0x080484b0 <+192>:	mov    al,BYTE PTR [eax]
   0x080484b2 <+194>:	cmp    dl,al
   0x080484b4 <+196>:	jne    0x80484e4 <main+244>
   0x080484b6 <+198>:	mov    dl,BYTE PTR [ebp-0x14]
   0x080484b9 <+201>:	mov    eax,DWORD PTR [ebp-0xc]
   0x080484bc <+204>:	inc    eax
   0x080484bd <+205>:	mov    al,BYTE PTR [eax]
   0x080484bf <+207>:	cmp    dl,al
   0x080484c1 <+209>:	jne    0x80484e4 <main+244>
   0x080484c3 <+211>:	mov    dl,BYTE PTR [ebp-0x13]
   0x080484c6 <+214>:	mov    eax,DWORD PTR [ebp-0xc]
   0x080484c9 <+217>:	add    eax,0xa
   0x080484cc <+220>:	mov    al,BYTE PTR [eax]
   0x080484ce <+222>:	cmp    dl,al
   0x080484d0 <+224>:	jne    0x80484e4 <main+244>
   0x080484d2 <+226>:	sub    esp,0xc
   0x080484d5 <+229>:	push   0x80c297a
   0x080484da <+234>:	call   0x80492d0 <puts>
   0x080484df <+239>:	add    esp,0x10
   0x080484e2 <+242>:	jmp    0x80484f4 <main+260>
   0x080484e4 <+244>:	sub    esp,0xc
   0x080484e7 <+247>:	push   0x80c298e
   0x080484ec <+252>:	call   0x80492d0 <puts>
   0x080484f1 <+257>:	add    esp,0x10
   0x080484f4 <+260>:	mov    eax,0x0
   0x080484f9 <+265>:	mov    ecx,DWORD PTR [ebp-0x4]
   0x080484fc <+268>:	leave  
   0x080484fd <+269>:	lea    esp,[ecx-0x4]
   0x08048500 <+272>:	ret    
End of assembler dump.
```
After inspecting the code we see that the entered password is stored in the "dl" register which is compared to the content of "al". This happens exactly four times. Therefore we will set breakpoints at those four addresses and define a hook-stop to set their values to the same. Thus, we get the following...  
```console
(gdb) break *0x080484a3
Breakpoint 2 at 0x80484a3
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>print/x $al
>set $dl = $al
>end
(gdb) n
Single stepping until exit from function main,
which has no line number information.
############################################################
##        Bienvennue dans ce challenge de cracking        ##
############################################################

Password :     
$1 = 0x65

Breakpoint 2, 0x080484a3 in main ()
(gdb) break *0x080484b2
Breakpoint 3 at 0x80484b2
(gdb) n
Single stepping until exit from function main,
which has no line number information.
$2 = 0x61

Breakpoint 3, 0x080484b2 in main ()
(gdb) break *0x080484bf
Breakpoint 4 at 0x80484bf
(gdb) n
Single stepping until exit from function main,
which has no line number information.
$3 = 0x73

Breakpoint 4, 0x080484bf in main ()
(gdb) break *0x080484ce
Breakpoint 5 at 0x80484ce
(gdb) n
Single stepping until exit from function main,
which has no line number information.
$4 = 0x79

Breakpoint 5, 0x080484ce in main ()
(gdb) 
Single stepping until exit from function main,
which has no line number information.

Good password !!!
```
We can see the following prints:  
$1 = 0x65  
$2 = 0x61  
$3 = 0x73  
$4 = 0x79  

Which represents "easy" in hex
