# Code Sigining
Manifest.MF file calculates a hash of every file thats in the APK (classes.dex,abc.properties,...)  
Here is an example for WhatsApp:  

Manifest-Version: 1.0

Name: AndroidManifest.xml
SHA1-Digest: 0pkPSIYR0GXNiJmqBxSNVwR6u1k=

Name: annotations/Assertions.java
SHA1-Digest: /I92B6ZXItkJyZEoLOci37tP+yM=

Name: annotations/Mutable.java
SHA1-Digest: ph1VThOqpM3KA4jBSuPdnu+/28w=

...  

One could say that we could just change the files we need and then recalculate the hash and update that hash in the MANIFEST.MF file but there is anothter file called CERT.SF which calculates the hash of the entire MANIFEST.MF file. Further it hashes the name and the sha1 hash (including the keywords "Name: " and "SHA1-Digest: " and appends it to the file. It can be seen below:  

Signature-Version: 1.0
Created-By: 1.0 (Android)
SHA1-Digest-Manifest: 8HMbYddN2C/g74emSPXgetDPiek=
X-Android-APK-Signed: 2, 3  

Name: AndroidManifest.xml
SHA1-Digest: cOhEgI9PcdVrP0WX8qglspuIzOk=  

Name: annotations/Assertions.java
SHA1-Digest: Kz5Cc2TjYqn3L1tta5tYdNCCQao=  

Name: annotations/Mutable.java
SHA1-Digest: hBVtpQZ4O59Wg4wgIltwRxhBgEw=  

...

Then we could still rehash the MANIFEST.MF file and then rehash he CERT.SF file. Therefore there is a CERT.RSA file which takes the CERF.SF file, hashes it and encrypts it with a private key and appends it to the CERT.RSA. Therefore if you want to check if the CERT.SF has been tampered with you need to take a public key to decrypt the hash and then compare the two hashes.

The problem with this is that Android does not use a CA so we can download the APK, resign and install it. No PKI is in palce that could verify the public key.

# Obfuscation

ProguardPro for example

# Disassembling

**smali** is an assembly language which compiles directly into DEX-Format  
**baksmali** takes a DEX file and shows assembly code  

**Apktool** is a tool for reverse engineering 3rd party, closed, binary Android apps. It can decode resources to nearly original form and rebuild them after making some modifications. It also makes working with an app easier because of the project like file structure and automation of some repetitive tasks like building apk, etc. Source: https://ibotpeaches.github.io/Apktool/

# Decompiling
It is not possible to rebuild the decompiled project. The workflow is usually to decompile and look what we want to change, find it in the disassembled SMALI code, change it there, and recompile it from there.  
**dex2jar**  
DEX -> Bytecode -> JAR  
Cannot rebuild a decompiled project so it is only for looking at the code

# Workflow example

1. Download the APK on the phone
1. Download it from your phone using adb
  1. adb shell pm list packages | grep <app name>
  1. adb shell pm path <package>
  1. adb pull <path to apk>
1. Patch the APK
  1. apktool decde <APK>
  1. View code with dex2jar
  1. Mess with the code
  1. apktool build -o <new APK> <disassembled APK dir>
1. Re-sign the APK
  1. java -jar apksigner.jar sign -ks <keystore> <patched APK>
  1. java -jar apksigner.jar verify -verbose <patched APK>



